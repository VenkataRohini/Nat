(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["isVisible"] = factory();
	else
		root["isVisible"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVisible = isVisible;
exports.isVisibleAll = isVisibleAll;
exports.isVisibleAny = isVisibleAny;

var _iselement = __webpack_require__(1);

var _iselement2 = _interopRequireDefault(_iselement);

var _styleProperties = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// cross-browser way of getting element's style property
function getStyle(element, property) {
  if (window.getComputedStyle) {
    return (0, _styleProperties.getStyleProperty)(element, property).original;
  } else if (element.currentStyle) {
    return element.currentStyle[property];
  }
  return null;
}

function isVisible(element) {
  // don't bother with non-element inputs
  if (!(0, _iselement2.default)(element)) {
    return false;
  }

  // This should prevent problems with ShadowDOMPolyfill. It returns different
  // object when asking directly via `document.body` (native element) and when
  // asking via `document.querySelector()` (wrapped element). This would result
  // in traversing too far in the `while` cycle below.
  var body_element = document.querySelector('body');
  var html_element = document.querySelector('html');

  // elements that are not inserted into the body are never visible
  if (!body_element || !body_element.contains(element)) {
    return false;
  }

  // invisible elements
  if (getStyle(element, 'visibility') === 'hidden') {
    return false;
  }

  // test display property recursively for element and all its parents, until BODY
  while (element && element !== body_element && element !== html_element) {
    if (getStyle(element, 'display') === 'none') {
      return false;
    }
    if (getStyle(element, 'opacity').toString() === '0') {
      return false;
    }
    element = element.parentNode;
  }

  return true;
}

function isVisibleAll(list) {
  for (var i = 0; i < list.length; i++) {
    if (!isVisible(list[i])) {
      return false;
    }
  }
  return true;
}

function isVisibleAny(list) {
  for (var i = 0; i < list.length; i++) {
    if (isVisible(list[i])) {
      return true;
    }
  }
  return false;
}

exports.default = isVisible;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = function (input) {
  return input != null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input.nodeType === 1 && _typeof(input.style) === 'object' && _typeof(input.ownerDocument) === 'object';
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

/**
 * Returns `true` if provided input is Element.
 * @name isElement
 * @param {*} [input]
 * @returns {boolean}
 */

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStyleProperty = getStyleProperty;
exports.getStyleProperties = getStyleProperties;

var _changeCase = __webpack_require__(3);

var _parsePropertyValue = __webpack_require__(4);

var _parsePropertyValue2 = _interopRequireDefault(_parsePropertyValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} StyleProperty
 * @property {string} unit - unit of the property, e.g. px, rgb
 * @property {string|number} value - value of the property
 * @property {string} output - valid string representation of value and unit
 *
 * @example <caption>Simple property.</caption>
 * {
 *   unit: 'px',
 *   value: 100,
 *   output: '100px'
 * }
 *
 * @example <caption>Color property.</caption>
 * {
 *   unit: 'rgb',
 *   value: [255, 255, 255],
 *   output: '#ffffff'
 * }
 */

/**
 * Attempts to fix the element when using Webcomponents with ShadowDOMPolyfill. It returns either original element or wrapped element, depending on whether the polyfill replaced the original `getComputedStyle` method or not.
 * This is madness and no sane person should ever do hacks like this. ShadowDOMPolyfill sucks donkey balls!
 * @param {Object|HTMLElement} element
 * @returns {Object|HTMLElement}
 */
function fixWebcomponentsElement(element) {
  if (typeof window.ShadowDOMPolyfill !== 'undefined') {

    var is_native = document.defaultView.getComputedStyle.toString().indexOf('[native code]') !== -1;

    // Can't check if element is instance of HTMLElement, because the polyfill
    // hijacks this. Only reliable way of checking if it is wrapped I found
    // is using this ugly ass property.
    var is_wrapped = typeof element.__impl4cf1e782hg__ !== 'undefined';

    if (is_native && is_wrapped) {
      element = window.ShadowDOMPolyfill.unwrap(element);
    }

    if (!is_native && !is_wrapped) {
      element = window.ShadowDOMPolyfill.wrap(element);
    }
  }

  return element;
}

/**
 * Returns information about unit and value of given property for given element.
 * @param {HTMLElement} element
 * @param {string} property - Name of the property. You can use either camelCase (e.g. zIndex) or kebab-case (e.g. z-index).
 * @returns {StyleProperty}
 *
 * @example
 * var element_width = getStyleProperty(my_element, 'width');
 * // returns {unit: 'px', value: 100, output: '100px'}
 */
function getStyleProperty(element, property) {
  property = (0, _changeCase.toKebabCase)(property);
  element = fixWebcomponentsElement(element);
  var value = document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
  return (0, _parsePropertyValue2.default)(value);
}

/**
 * Returns information about multiple properties of given element.
 * @param {HTMLElement} element
 * @param {Array|string} properties - List of properties. Single property (string) will be converted to an array.
 * @returns {Object} - Keys of the returned objects are property names, values are objects containing information about given property.
 *
 * @example
 * var element_size = getStyleProperties(my_element, ['width', 'height']);
 * // returns
 * // {
 * //   width: {unit: 'px', value: 100, output: '100px'},
 * //   height: {unit: 'px', value: 100, output: '100px'}
 * // }
 */
function getStyleProperties(element) {
  var properties = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (typeof properties === 'string') {
    properties = [properties];
  }

  var result = {};

  properties.forEach(function (property) {
    result[property] = getStyleProperty(element, property);
  });

  return result;
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toCamelCase = toCamelCase;
exports.toKebabCase = toKebabCase;
var delimiters = [' ', '-', '_'];

function toCamelCase() {
  var input = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

  var characters = input.split('');
  var result = [];

  var character = void 0;
  while (character = characters.shift()) {
    if (delimiters.indexOf(character) !== -1) {
      if (character = characters.shift()) {
        character = character.toUpperCase();
      }
    }
    result.push(character);
  }

  return result.join('');
}

function toKebabCase() {
  var input = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

  var characters = input.split('');
  var result = [];

  characters.forEach(function (character) {
    var lowercase_character = character.toLowerCase();
    if (character !== lowercase_character) {
      result.push('-', lowercase_character);
    } else if (delimiters.indexOf(character) !== -1) {
      result.push('-');
    } else {
      result.push(character);
    }
  });

  return result.join('');
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (value) {
  var result = re_color.test(value) ? parseColorProperty(value) : parseRegularProperty(value);
  result.original = value;
  return result;
};

var re_color = /^rgb\((\d+),\s?(\d+),\s?(\d+)\)$/;
var re_prop = /^(-?\d*\.?\d*)(.*)$/;

// converts number in base 10 to base 16, adds padding zero if needed
function convertColorComponent(input) {
  var result = input.toString(16);
  if (result.length < 2) {
    result = '0' + result;
  }
  return result;
}

function parseColorProperty(value) {
  var matches = value.match(re_color);
  var result = {};

  result.unit = 'rgb';

  result.value = [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3], 10)];

  result.output = '#' + convertColorComponent(result.value[0]) + convertColorComponent(result.value[1]) + convertColorComponent(result.value[2]);

  return result;
}

function parseRegularProperty(value) {
  var result = {
    unit: '',
    value: null,
    output: 'auto'
  };

  if (value !== 'auto') {
    var matches = value.match(re_prop);
    result.value = parseFloat(matches[1]);
    result.unit = matches[2];
    result.output = result.value + result.unit;
  }

  return result;
}

/***/ })
/******/ ]);
});